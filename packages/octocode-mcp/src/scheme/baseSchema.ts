/**
 * Base schema definitions for all MCP tools
 * Provides consistent foundation for research goal integration and LLM reasoning
 */

import { z } from 'zod';

/**
 * Base query schema that all tool queries should extend
 * Ensures consistent research goal integration across all tools
 */
export const BaseQuerySchema = z.object({
  id: z.string().optional().describe('generate query id (1,2,3, etc.)'),

  queryDescription: z.string().optional().describe('Query research purpose'),

  verbose: z.boolean().optional().default(false).describe('Add debug info'),
});

/**
 * Base query interface for TypeScript
 */
export interface BaseQuery {
  id?: string;
  queryDescription?: string;
  verbose?: boolean;
}

/**
 * Base bulk operation schema for tools supporting multiple queries
 */
export const BaseBulkQuerySchema = z.object({
  queries: z.array(BaseQuerySchema).min(1).describe('Queries'),
});

/**
 * Base bulk operation interface
 */
export interface BaseBulkQuery {
  queries: BaseQuery[];
}

/**
 * Standard meta interface for all tool responses
 */
export interface BaseToolMeta {
  totalOperations: number;
  successfulOperations: number;
  failedOperations: number;
  errors?: Array<{
    operationId: string;
    error: string;
    hints?: string[];
  }>;
}

/**
 * Standard result interface for failed queries
 */
export interface BaseFailedResult {
  queryId?: string; // Sequential query ID generated by bulk operations
  failed: true;
  hints: string[];
  meta: {
    queryArgs: Record<string, unknown>;
    error?: string;
    searchType?: string;
    suggestions?: Record<string, unknown>;
  };
}

/**
 * Helper function to extend base query schema with tool-specific fields
 */
export function extendBaseQuerySchema<T extends z.ZodRawShape>(
  toolSpecificSchema: T
) {
  return BaseQuerySchema.extend(toolSpecificSchema);
}

/**
 * Helper function to create bulk query schema for any tool
 */
export function createBulkQuerySchema<T extends z.ZodTypeAny>(
  singleQuerySchema: T,
  minQueries: number = 1,
  maxQueries: number = 10,
  description: string
) {
  return z.object({
    queries: z
      .array(singleQuerySchema)
      .min(minQueries)
      .max(maxQueries)
      .describe(description),
    verbose: z.boolean().optional().default(false).describe('Add debug info'),
  });
}

/**
 * Common pagination schema for tools that support it
 */
export const PaginationSchema = z.object({
  limit: z.number().int().min(1).max(20).optional().describe('Max results'),

  offset: z.number().int().min(0).optional().describe('Skip count'),
});

/**
 * Common sorting schema
 */
export const SortingSchema = z.object({
  sort: z.string().optional().describe('Sort field'),

  order: z.enum(['asc', 'desc']).optional().default('desc').describe('Order'),
});

/**
 * Common filter schema for text search
 */
export const TextSearchSchema = z.object({
  query: z.string().min(1).optional().describe('Query'),

  queryTerms: z.array(z.string()).optional().describe('Terms (AND)'),
});

/**
 * Common repository filter schema
 */
export const RepositoryFilterSchema = z.object({
  owner: z
    .union([z.string(), z.array(z.string())])
    .optional()
    .describe('Owner(s)'),

  repo: z
    .union([z.string(), z.array(z.string())])
    .optional()
    .describe('Repo(s)'),

  language: z.string().optional().describe('Language'),

  visibility: z
    .enum(['public', 'private', 'internal'])
    .optional()
    .describe('Visibility'),
});

/**
 * Common GitHub repository owner validation schema
 */
export const GitHubOwnerSchema = z
  .string()
  .min(1)
  .max(150)
  .regex(/^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?$/)
  .describe('Owner/org');

/**
 * Common GitHub repository name validation schema
 */
export const GitHubRepoSchema = z
  .string()
  .min(1)
  .max(150)
  .regex(/^[a-zA-Z0-9._-]+$/)
  .describe('Repo name');

/**
 * Common GitHub branch validation schema
 */
export const GitHubBranchSchema = z
  .string()
  .min(1)
  .max(255)
  .regex(/^[^\s]+$/)
  .describe('Branch/tag/SHA');

/**
 * Common file path validation schema
 */
export const GitHubFilePathSchema = z.string().min(1).describe('Path (no /)');

/**
 * Common limit schema for pagination
 */
export const LimitSchema = z
  .number()
  .int()
  .min(1)
  .max(20)
  .optional()
  .describe('Max');

/**
 * Common boolean optimization flags
 */
export const OptimizationFlagsSchema = z.object({
  minify: z.boolean().optional().default(true).describe('Minify'),

  sanitize: z.boolean().optional().default(true).describe('Sanitize'),
});

/**
 * Minified schema - commonly used across file content and search tools
 */
export const MinifiedSchema = z.boolean().default(true).describe('Minify');

/**
 * Common match scope schemas for different search types
 */
export const FileMatchScopeSchema = z
  .union([z.enum(['file', 'path']), z.array(z.enum(['file', 'path']))])
  .optional()
  .describe('Scope');

export const PRMatchScopeSchema = z
  .array(z.enum(['title', 'body', 'comments']))
  .optional()
  .describe('Fields');

export const RepoMatchScopeSchema = z
  .union([
    z.enum(['name', 'description', 'readme']),
    z.array(z.enum(['name', 'description', 'readme'])),
    z.null(),
  ])
  .optional()
  .describe('Scope');

/**
 * Common date range filter schema
 */
export const DateRangeSchema = z.object({
  created: z
    .string()
    .regex(
      /^(>=?\d{4}-\d{2}-\d{2}|<=?\d{4}-\d{2}-\d{2}|\d{4}-\d{2}-\d{2}\.\.\d{4}-\d{2}-\d{2}|\d{4}-\d{2}-\d{2})$/
    )
    .optional()
    .describe('Created'),

  updated: z
    .string()
    .regex(
      /^(>=?\d{4}-\d{2}-\d{2}|<=?\d{4}-\d{2}-\d{2}|\d{4}-\d{2}-\d{2}\.\.\d{4}-\d{2}-\d{2}|\d{4}-\d{2}-\d{2})$/
    )
    .optional()
    .describe('Updated'),
});

/**
 * Common numeric range filter schema
 */
export const NumericRangeSchema = z.object({
  stars: z
    .union([
      z.number().int().min(0),
      z.string().regex(/^(>=?\d+|<=?\d+|\d+\.\.\d+|\d+)$/),
    ])
    .optional()
    .describe('Stars'),
});

/**
 * Common boolean state filters
 */
export const StateFilterSchema = z.object({
  // archived and fork parameters removed - always optimized to exclude archived repositories and forks for better quality
  locked: z.boolean().optional().describe('Locked'),

  draft: z.boolean().optional().describe('Draft'),
});

/**
 * Common array field schema with flexible types
 */
export const FlexibleArraySchema = {
  stringOrArray: z.union([z.string(), z.array(z.string())]).optional(),
  stringOrArrayOrNull: z
    .union([z.string(), z.array(z.string()), z.null()])
    .optional(),
  numberOrStringRange: z
    .union([
      z.number().int().min(0),
      z.string().regex(/^(>=?\d+|<=?\d+|\d+\.\.\d+|\d+)$/),
    ])
    .optional(),
  numberOrStringRangeOrNull: z
    .union([
      z.number().int().min(0),
      z.string().regex(/^(>=?\d+|<=?\d+|\d+\.\.\d+|\d+)$/),
      z.null(),
    ])
    .optional(),
};

/**
 * Standard result interfaces
 */
export interface BaseResult {
  queryId?: string; // Sequential query ID generated by bulk operations
  failed?: boolean;
  hints?: string[];
}

export interface BaseSuccessResult extends BaseResult {
  failed?: false;
}

export interface BaseFailureResult extends BaseResult {
  failed: true;
  error: string;
  suggestions?: {
    broaderSearch?: string[];
    semanticAlternatives?: string[];
    relatedTerms?: string[];
  };
}
